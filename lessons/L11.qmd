---
title:   "DiseÃ±o de Arquitectura"
subtitle: "Patrones de diseÃ±o"
format:
  kotlin-quarto-revealjs-theme-revealjs:
    incremental: true
    footer: "Universidad CENFOTEC Â©"
    logo: imgs/logo.png
author:
    - name: Kevin A. HernÃ¡ndez RostrÃ¡n
      degrees:
        - M.Sc.
      orcid: 0009-0001-7682-0350
      email: khernandez@ucenfotec.ac.cr
      affiliation:
        - name: Universidad Cenfotec
          url: https://ucenfotec.ac.cr/
---

## ğŸ’­ IntroducciÃ³n

> *"Cada patrÃ³n describe un problema que ocurre una y otra vez en nuestro entorno, y luego describe el nÃºcleo de la soluciÃ³n a ese problema, de tal manera que puedes usar esta soluciÃ³n un millÃ³n de veces sin hacerlo de la misma forma dos veces."*

**â€” Christopher Alexander, Arquitecto**

---

## ğŸ¯ Objetivos de la sesiÃ³n

- Comprender los **patrones de diseÃ±o GoF** y sus categorÃ­as
- Implementar patrones **Creacionales, Estructurales y De Comportamiento**
- Conocer los **patrones arquitectÃ³nicos PoSA**
- Aplicar patrones usando **Docker** en proyectos reales
- Identificar **cuÃ¡ndo y cÃ³mo** usar cada patrÃ³n

---

## ğŸ“š Â¿QuÃ© son los Patrones de DiseÃ±o?

> Los **patrones de diseÃ±o** son soluciones reutilizables a problemas comunes en el diseÃ±o de software.

### âœ… Beneficios:
- **ReutilizaciÃ³n** - Soluciones probadas y documentadas
- **ComunicaciÃ³n** - Vocabulario comÃºn entre desarrolladores
- **Mantenibilidad** - CÃ³digo mÃ¡s estructurado y comprensible
- **Escalabilidad** - Arquitecturas mÃ¡s flexibles

---

## ğŸ“š Â¿QuÃ© son los Patrones de DiseÃ±o?

### ğŸ“– Dos categorÃ­as principales:
1. **Patrones de DiseÃ±o (GoF)** - Nivel de cÃ³digo/clases
2. **Patrones ArquitectÃ³nicos (PoSA)** - Nivel de sistema/aplicaciÃ³n

---

# ğŸ© Patrones GoF
## Gang of Four Design Patterns

---

## ğŸ“– Contexto: Patrones GoF

**The Gang of Four (GoF)** son un conjunto de patrones de diseÃ±o para desarrollo de software orientado a objetos, descritos por primera vez en el libro *"Design Patterns: Elements of Reusable Object-Oriented Software"*.

**Autores:** Erich Gamma, Richard Helm, Ralph Johnson, y John Vlissides

**AÃ±o:** 1994 - Â¡Casi 30 aÃ±os y siguen siendo relevantes!

---

## ğŸ—‚ï¸ CategorÃ­as de Patrones GoF

Los patrones GoF se dividen en **3 categorÃ­as principales**:

| CategorÃ­a | PropÃ³sito | Enfoque |
|-----------|-----------|---------|
| **ğŸ—ï¸ Creacionales** | **CÃ³mo** crear objetos | CreaciÃ³n de instancias |
| **ğŸ”— Estructurales** | **CÃ³mo** componer objetos | ComposiciÃ³n de clases/objetos |
| **ğŸ­ De Comportamiento** | **CÃ³mo** interactÃºan objetos | ComunicaciÃ³n entre objetos |

---

## ğŸ—ï¸ Patrones Creacionales

### Objetivo: Controlar la **creaciÃ³n de objetos**

**Problema:** Crear objetos directamente puede crear dependencias y rigidez.

**SoluciÃ³n:** Abstraer el proceso de creaciÃ³n de objetos.

---

## ğŸ—ï¸ Patrones Creacionales - Lista

| PatrÃ³n | PropÃ³sito |
|--------|-----------|
| **Singleton** | Una sola instancia en toda la aplicaciÃ³n |
| **Factory Method** | Crear objetos sin especificar clase exacta |
| **Abstract Factory** | Crear familias de objetos relacionados |
| **Builder** | Construir objetos complejos paso a paso |
| **Prototype** | Crear objetos clonando instancias existentes |

---

### ğŸ¯ Ejemplo: Singleton Pattern

**Problema:** Necesito una sola instancia de configuraciÃ³n en toda la app.

```csharp
public sealed class ConfigManager
{
  private static ConfigManager _instance = null;
  private static readonly object _lock = new object();
  private Dictionary<string, string> _config;

  private ConfigManager()
  {
    _config = new Dictionary<string, string>
    {
      {"DatabaseUrl", "localhost:5432"},
      {"ApiKey", "abc123"}
    };
  }

  public static ConfigManager Instance
  {
    get
    {
      if (_instance == null)
      {
        lock (_lock)
        {
          if (_instance == null)
            _instance = new ConfigManager();
        }
      }
      return _instance;
    }
  }

  public string GetConfig(string key) => _config.GetValueOrDefault(key);
}
```

---

### ğŸ¯ Ejemplo: Singleton Pattern

**Uso:**
```csharp
var config = ConfigManager.Instance;
string dbUrl = config.GetConfig("DatabaseUrl");
```

---

### ğŸ¯ Ejemplo: Factory Method Pattern

**Problema:** Crear diferentes tipos de notificaciones sin acoplar cÃ³digo.

```csharp
// Producto abstracto
public abstract class Notification
{
  public abstract void Send(string message);
}

// Productos concretos
public class EmailNotification : Notification
{
  public override void Send(string message)
    => Console.WriteLine($"ğŸ“§ Email: {message}");
}

public class SMSNotification : Notification
{
  public override void Send(string message)
    => Console.WriteLine($"ğŸ“± SMS: {message}");
}

// Factory
public abstract class NotificationFactory
{
  public abstract Notification CreateNotification();
}

public class EmailFactory : NotificationFactory
{
  public override Notification CreateNotification()
    => new EmailNotification();
}

// Uso
var factory = new EmailFactory();
var notification = factory.CreateNotification();
notification.Send("Â¡Hola mundo!");
```

---

## ğŸ”— Patrones Estructurales

### Objetivo: **Componer objetos** para formar estructuras mÃ¡s grandes

**Problema:** Necesito que objetos incompatibles trabajen juntos.

**SoluciÃ³n:** Proporcionar formas de componer objetos manteniendo flexibilidad.

---

## ğŸ”— Patrones Estructurales - Lista

| PatrÃ³n | PropÃ³sito |
|--------|-----------|
| **Adapter** | Hacer compatibles interfaces incompatibles |
| **Bridge** | Separar abstracciÃ³n de implementaciÃ³n |
| **Composite** | Componer objetos en estructuras tipo Ã¡rbol |
| **Decorator** | Agregar funcionalidad dinÃ¡micamente |
| **Facade** | Interfaz simple para subsistema complejo |
| **Flyweight** | Compartir eficientemente objetos similares |
| **Proxy** | Placeholder o representante de otro objeto |

---

### ğŸ¯ Ejemplo: Adapter Pattern

**Problema:** Sistema legacy con interfaz incompatible.

```csharp
// Servicio legacy (no podemos modificar)
public class LegacyPaymentSystem
{
    public void ProcessLegacyPayment(string cardNumber, double amount)
    {
        Console.WriteLine($"Legacy: Processing ${amount} from card {cardNumber}");
    }
}

// Nueva interfaz que queremos usar
public interface IPaymentProcessor
{
    void ProcessPayment(PaymentRequest request);
}

// Adapter que hace compatible el sistema legacy
public class PaymentAdapter : IPaymentProcessor
{
    private LegacyPaymentSystem _legacySystem;

    public PaymentAdapter(LegacyPaymentSystem legacySystem)
    {
        _legacySystem = legacySystem;
    }

    public void ProcessPayment(PaymentRequest request)
    {
        // Adaptamos la nueva interfaz a la legacy
        _legacySystem.ProcessLegacyPayment(
            request.CardNumber,
            request.Amount
        );
    }
}

// Uso
var legacySystem = new LegacyPaymentSystem();
IPaymentProcessor processor = new PaymentAdapter(legacySystem);
processor.ProcessPayment(new PaymentRequest
{
    CardNumber = "1234-5678",
    Amount = 100.50
});
```

---

### ğŸ¯ Ejemplo: Decorator Pattern

**Problema:** Agregar funcionalidades a objetos dinÃ¡micamente.

```csharp
// Componente base
public interface ICoffee
{
    string GetDescription();
    double GetCost();
}

// ImplementaciÃ³n concreta
public class SimpleCoffee : ICoffee
{
    public string GetDescription() => "CafÃ© simple";
    public double GetCost() => 2.00;
}

// Decorator base
public abstract class CoffeeDecorator : ICoffee
{
    protected ICoffee _coffee;

    public CoffeeDecorator(ICoffee coffee)
    {
        _coffee = coffee;
    }

    public virtual string GetDescription() => _coffee.GetDescription();
    public virtual double GetCost() => _coffee.GetCost();
}

// Decorators concretos
public class MilkDecorator : CoffeeDecorator
{
    public MilkDecorator(ICoffee coffee) : base(coffee) { }

    public override string GetDescription()
        => _coffee.GetDescription() + ", Leche";
    public override double GetCost()
        => _coffee.GetCost() + 0.50;
}

public class SugarDecorator : CoffeeDecorator
{
    public SugarDecorator(ICoffee coffee) : base(coffee) { }

    public override string GetDescription()
        => _coffee.GetDescription() + ", AzÃºcar";
    public override double GetCost()
        => _coffee.GetCost() + 0.25;
}

// Uso: construir cafÃ© dinÃ¡micamente
ICoffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);

Console.WriteLine($"{coffee.GetDescription()}: ${coffee.GetCost()}");
// Output: "CafÃ© simple, Leche, AzÃºcar: $2.75"
```

---

## ğŸ­ Patrones De Comportamiento

### Objetivo: **ComunicaciÃ³n y responsabilidades** entre objetos

**Problema:** Objetos necesitan interactuar de forma flexible y mantenible.

**SoluciÃ³n:** Definir cÃ³mo los objetos colaboran y se comunican.

---

## ğŸ­ Patrones De Comportamiento - Lista

| PatrÃ³n | PropÃ³sito |
|--------|-----------|
| **Observer** | Notificar cambios a mÃºltiples objetos |
| **Strategy** | Intercambiar algoritmos dinÃ¡micamente |
| **Command** | Encapsular solicitudes como objetos |
| **State** | Cambiar comportamiento segÃºn estado interno |
| **Template Method** | Definir algoritmo base, customizar pasos |
| **Chain of Responsibility** | Pasar solicitudes por cadena de handlers |
| **Visitor** | Separar algoritmos de estructuras |
| **Mediator** | Mediar comunicaciÃ³n entre objetos |

---

### ğŸ¯ Ejemplo: Observer Pattern

**Problema:** MÃºltiples objetos necesitan reaccionar a cambios de estado.

```csharp
// Subject (Observable)
public interface ISubject
{
    void Attach(IObserver observer);
    void Detach(IObserver observer);
    void Notify();
}

// Observer
public interface IObserver
{
    void Update(ISubject subject);
}

// Subject concreto
public class WeatherStation : ISubject
{
    private List<IObserver> _observers = new List<IObserver>();
    private float _temperature;

    public float Temperature
    {
        get { return _temperature; }
        set
        {
            _temperature = value;
            Notify(); // Notificar cuando cambia
        }
    }

    public void Attach(IObserver observer)
        => _observers.Add(observer);

    public void Detach(IObserver observer)
        => _observers.Remove(observer);

    public void Notify()
    {
        foreach (var observer in _observers)
            observer.Update(this);
    }
}

// Observers concretos
public class PhoneDisplay : IObserver
{
    public void Update(ISubject subject)
    {
        if (subject is WeatherStation station)
            Console.WriteLine($"ğŸ“± TelÃ©fono: Temperatura {station.Temperature}Â°C");
    }
}

public class WebDisplay : IObserver
{
    public void Update(ISubject subject)
    {
        if (subject is WeatherStation station)
            Console.WriteLine($"ğŸŒ Web: Temperatura {station.Temperature}Â°C");
    }
}

// Uso
var weatherStation = new WeatherStation();
var phoneDisplay = new PhoneDisplay();
var webDisplay = new WebDisplay();

weatherStation.Attach(phoneDisplay);
weatherStation.Attach(webDisplay);

weatherStation.Temperature = 25.5f;
// Output:
// ğŸ“± TelÃ©fono: Temperatura 25.5Â°C
// ğŸŒ Web: Temperatura 25.5Â°C
```

---

### ğŸ¯ Ejemplo: Strategy Pattern

**Problema:** Diferentes algoritmos para la misma tarea.

```csharp
// Estrategia
public interface IPaymentStrategy
{
    void Pay(double amount);
}

// Estrategias concretas
public class CreditCardStrategy : IPaymentStrategy
{
    private string _cardNumber;

    public CreditCardStrategy(string cardNumber)
    {
        _cardNumber = cardNumber;
    }

    public void Pay(double amount)
    {
        Console.WriteLine($"ğŸ’³ Pagando ${amount} con tarjeta {_cardNumber}");
    }
}

public class PayPalStrategy : IPaymentStrategy
{
    private string _email;

    public PayPalStrategy(string email)
    {
        _email = email;
    }

    public void Pay(double amount)
    {
        Console.WriteLine($"ğŸ¦ Pagando ${amount} con PayPal ({_email})");
    }
}

// Contexto
public class ShoppingCart
{
    private IPaymentStrategy _paymentStrategy;

    public void SetPaymentStrategy(IPaymentStrategy strategy)
    {
        _paymentStrategy = strategy;
    }

    public void Checkout(double amount)
    {
        _paymentStrategy?.Pay(amount);
    }
}

// Uso
var cart = new ShoppingCart();

// Pagar con tarjeta
cart.SetPaymentStrategy(new CreditCardStrategy("1234-5678"));
cart.Checkout(99.99);

// Cambiar a PayPal
cart.SetPaymentStrategy(new PayPalStrategy("user@email.com"));
cart.Checkout(99.99);
```

---

## ğŸ¯ Resumen: Â¿CuÃ¡ndo usar cada categorÃ­a?

| SituaciÃ³n | CategorÃ­a | Ejemplo |
|-----------|-----------|---------|
| **Controlar creaciÃ³n de objetos** | ğŸ—ï¸ Creacional | Una sola instancia de DB â†’ Singleton |
| **Interfaces incompatibles** | ğŸ”— Estructural | API legacy â†’ Adapter |
| **Algoritmos intercambiables** | ğŸ­ Comportamental | MÃ©todos de pago â†’ Strategy |
| **Notificar cambios** | ğŸ­ Comportamental | UI updates â†’ Observer |
| **Agregar funcionalidad** | ğŸ”— Estructural | Personalizar cafÃ© â†’ Decorator |

---

## ğŸŒ‰ TransiciÃ³n: De GoF a PoSA

### ğŸ—ï¸ **Patrones GoF** (Nivel de cÃ³digo)
- **Alcance:** Clases y objetos individuales
- **Problema:** CÃ³mo crear, estructurar y hacer interactuar objetos
- **Ejemplos:** Singleton, Factory, Observer, Strategy

### ğŸ›ï¸ **Patrones PoSA** (Nivel arquitectÃ³nico)
- **Alcance:** Sistemas completos y aplicaciones distribuidas
- **Problema:** CÃ³mo estructurar aplicaciones escalables y confiables
- **Ejemplos:** Microservicios, Load Balancing, Service Discovery

**ğŸ’¡ Ambos se complementan:** GoF para implementar componentes, PoSA para conectarlos.

---

# ğŸ›ï¸ Patrones PoSA
## Patterns of Scalable, Reliable Services

---

## ğŸ’­ IntroducciÃ³n PoSA

> *"En un mundo donde la escala y la confiabilidad son requisitos, no caracterÃ­sticas opcionales, los patrones arquitectÃ³nicos se convierten en el lenguaje comÃºn que permite a los equipos construir sistemas verdaderamente resilientes."*

**â€” Kevin Hoffman, Patterns of Scalable, Reliable Services**

---

## Patrones PoSA
### Arquitectura de Software Orientada a Patrones

Los patrones PoSA ofrecen soluciones reutilizables y probadas para diseÃ±ar sistemas de software **escalables, modulares y adaptables**.

Basado en:
ğŸ“˜ *Patterns of Scalable, Reliable Services*
ğŸ‘¨â€ğŸ’» Autor: Kevin Hoffman

---

## CategorÃ­as de Patrones PoSA

Los patrones se agrupan en 4 categorÃ­as principales:

1. **Partitioning Patterns** â€“ Dividir el sistema en partes manejables
2. **Placement Patterns** â€“ DÃ³nde desplegar o ubicar componentes
3. **Routing Patterns** â€“ CÃ³mo enrutar solicitudes y mensajes
4. **Federation Patterns** â€“ CÃ³mo colaborar entre mÃºltiples instancias o dominios

---

## Partitioning Patterns
### Divide y vencerÃ¡s

Estos patrones ayudan a dividir el sistema en **partes independientes** para mejorar el escalamiento, el mantenimiento y la resiliencia.

---

## ğŸ¯ Contexto: Partitioning Patterns

### Â¿CuÃ¡ndo usar?
- Sistemas **monolÃ­ticos** que necesitan escalar
- Equipos **grandes** que necesitan trabajar independientemente
- Diferentes **cargas de trabajo** con requisitos distintos

### âœ… Beneficios:
- **Escalabilidad independiente** - cada parte se escala segÃºn su demanda
- **Desarrollo paralelo** - equipos pueden trabajar sin interferir
- **Tolerancia a fallos** - falla una parte, el resto sigue funcionando
- **TecnologÃ­as especializadas** - cada parte usa la tecnologÃ­a mÃ¡s apropiada

---

## ğŸ¯ Contexto: Partitioning Patterns

### âš ï¸ DesafÃ­os:
- **Complejidad de red** - mÃ¡s comunicaciÃ³n entre servicios
- **GestiÃ³n de datos** - consistencia entre particiones
- **Monitoreo distribuido** - visibilidad del sistema completo

---

### PatrÃ³n: Functional Decomposition

Divide un sistema por **dominios funcionales**.
Ejemplo: usuarios, pagos, pedidos.

```{.yml .code-block}
## docker-compose.yaml
version: "3.8"
services:
  usuarios:
    image: miapp/usuarios
    ports:
      - "8081:80"
  pagos:
    image: miapp/pagos
    ports:
      - "8082:80"
  pedidos:
    image: miapp/pedidos
    ports:
      - "8083:80"
```

â¡ï¸ Cada servicio se puede desarrollar, desplegar y escalar por separado.

---

### PatrÃ³n: Data Partitioning (Sharding)

Divide los datos entre mÃºltiples instancias.

```{.yml .code-block}
## docker-compose.yaml simulando sharding
version: "3.8"
services:
  db-shard-1:
    image: mongo
    ports:
      - "27017:27017"
    environment:
      - SHARD_ID=shard1

  db-shard-2:
    image: mongo
    ports:
      - "27018:27017"
    environment:
      - SHARD_ID=shard2
```

ğŸ“Œ Cada contenedor actÃºa como una particiÃ³n de datos.

---

## Placement Patterns
### Â¿DÃ³nde ubicar componentes?

Estos patrones definen **dÃ³nde ejecutar cada componente**, segÃºn cercanÃ­a o capacidad del entorno.

---

## ğŸ¯ Contexto: Placement Patterns

### Â¿CuÃ¡ndo usar?
- **Latencia** es crÃ­tica para la experiencia del usuario
- Recursos **limitados** que deben optimizarse
- **Regulaciones** requieren datos en ubicaciones especÃ­ficas
- **Costos** de infraestructura deben minimizarse

### âœ… Beneficios:
- **Menor latencia** - servicios cerca del usuario final
- **OptimizaciÃ³n de recursos** - usar la capacidad disponible eficientemente
- **Cumplimiento regulatorio** - datos en jurisdicciones correctas
- **ReducciÃ³n de costos** - usar recursos mÃ¡s baratos cuando sea posible

---

## ğŸ¯ Contexto: Placement Patterns

### âš ï¸ DesafÃ­os:
- **GestiÃ³n compleja** - mÃºltiples ubicaciones para administrar
- **SincronizaciÃ³n** - mantener consistencia entre ubicaciones
- **Failover** - quÃ© hacer cuando una ubicaciÃ³n falla

---

### PatrÃ³n: Locality-Aware Placement

Ubica los servicios **cerca del consumidor final**.

```{.yml .code-block}
## docker-compose con redes separadas
networks:
  zona_eu:
  zona_us:

services:
  servicio-eu:
    image: miapp/app
    networks:
      - zona_eu

  servicio-us:
    image: miapp/app
    networks:
      - zona_us
```

ğŸŒ Esto permite simular regiones o zonas geogrÃ¡ficas locales.

---

### PatrÃ³n: Resource-Aware Placement

Ejecuta servicios segÃºn requisitos de recursos.

```{.yml .code-block}
## Ejecutar con lÃ­mites de recursos
docker run -d   --memory="512m"   --cpus="0.5"   --name servicio-ligero   miapp/app
```

âš–ï¸ Este patrÃ³n optimiza el uso de recursos disponibles en el host.

---

## Routing Patterns
### Â¿CÃ³mo se enrutan las solicitudes?

Estos patrones definen **cÃ³mo dirigir el trÃ¡fico** hacia los servicios apropiados.

---

## ğŸ¯ Contexto: Routing Patterns

### Â¿CuÃ¡ndo usar?
- **MÃºltiples versiones** del mismo servicio en producciÃ³n
- **Balanceador de carga** necesario para distribuir trÃ¡fico
- **A/B testing** o **canary deployments** requeridos
- **Servicios especializados** segÃºn tipo de solicitud

### âœ… Beneficios:
- **Flexibilidad de despliegue** - dirigir trÃ¡fico segÃºn necesidades
- **Zero-downtime deployments** - cambiar versiones sin interrupciones
- **Testing en producciÃ³n** - probar nuevas funcionalidades gradualmente
- **OptimizaciÃ³n de rendimiento** - enrutar segÃºn capacidad o latencia

---

## ğŸ¯ Contexto: Routing Patterns

### âš ï¸ DesafÃ­os:
- **Punto de falla Ãºnico** - el router puede ser crÃ­tico
- **ConfiguraciÃ³n compleja** - reglas de enrutamiento pueden ser complicadas
- **Observabilidad** - rastrear flujo de solicitudes entre servicios

---

### PatrÃ³n: Client-Side Routing

El cliente decide a quÃ© endpoint conectarse.

```{.yml .code-block}
## JavaScript (cliente)
const region = detectUserRegion();
const url = region === 'EU'
  ? 'http://localhost:8081'
  : 'http://localhost:8082';

fetch(url + '/status');
```

ğŸ“ Ãštil para enrutar segÃºn regiÃ³n u origen de usuario.

---

### PatrÃ³n: Reverse Proxy Routing

Un proxy enruta el trÃ¡fico segÃºn el path o encabezados.

```{.yml .code-block}
## docker-compose con Nginx como reverse proxy
version: "3.8"
services:
  proxy:
    image: nginx
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    ports:
      - "80:80"

  pagos:
    image: miapp/pagos
    ports:
      - "8082:80"

  usuarios:
    image: miapp/usuarios
    ports:
      - "8081:80"
```

ğŸ“¬ Nginx actÃºa como punto central de enrutamiento.

---

## Federation Patterns
### ColaboraciÃ³n entre dominios o clusters

Permiten que mÃºltiples sistemas trabajen en conjunto sin perder autonomÃ­a.

---

## ğŸ¯ Contexto: Federation Patterns

### Â¿CuÃ¡ndo usar?
- **MÃºltiples organizaciones** necesitan colaborar
- **Sistemas legacy** deben integrarse con modernos
- **Microservicios** necesitan compartir funcionalidades comunes
- **Multi-cloud** o **hÃ­brido** deployments

### âœ… Beneficios:
- **AutonomÃ­a preservada** - cada dominio mantiene independencia
- **ReutilizaciÃ³n** - servicios compartidos entre dominios
- **Interoperabilidad** - sistemas diferentes pueden colaborar
- **Gobernanza distribuida** - cada equipo controla su dominio

---

## ğŸ¯ Contexto: Federation Patterns

### âš ï¸ DesafÃ­os:
- **Contratos de API** - mantener compatibilidad entre dominios
- **Seguridad compleja** - autenticaciÃ³n y autorizaciÃ³n cross-domain
- **Debugging distribuido** - problemas pueden cruzar mÃºltiples dominios
- **Versionado** - coordinar cambios entre mÃºltiples equipos

---

### PatrÃ³n: Service Federation

Simula consumir servicios externos desde otro entorno o red.

```{.yml .code-block}
## docker-compose con ExternalName simulado usando proxy
version: "3.8"
services:
  proxy:
    image: nginx
    volumes:
      - ./nginx-externo.conf:/etc/nginx/nginx.conf
    ports:
      - "8080:80"

  servicio-local:
    image: miapp/local
    ports:
      - "8085:80"
```

ğŸ”— El proxy actÃºa como puente a servicios federados externos.

---

### PatrÃ³n: Shared Identity

MÃºltiples servicios usan el mismo proveedor de identidad.

```{.yml .code-block}
## docker-compose con servicio que consume OIDC
version: "3.8"
services:
  servicio:
    image: miapp/secure-app
    environment:
      - OIDC_ISSUER=https://login.empresa.com
```

ğŸ” Asegura una identidad comÃºn entre servicios distribuidos.

---

## ConclusiÃ³n

âœ… Los patrones PoSA ayudan a construir sistemas **modulares, escalables y mantenibles**.

ğŸ³ Usando **Docker**, podemos implementar fÃ¡cilmente estos patrones en entornos modernos.

ğŸ“š MÃ¡s info: *Patterns of Scalable, Reliable Services* â€” Kevin Hoffman

---

## ğŸ› ï¸ PrÃ¡ctica: Implementando Patrones PoSA

### Objetivo
Implementar **patrones PoSA** (Functional Decomposition + Reverse Proxy Routing) en un sistema de e-commerce.

---

## ğŸ“ Paso 1: Estructura del Proyecto

Crear la siguiente estructura de carpetas:

```
mitienda/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ nginx/
â”‚   â””â”€â”€ nginx.conf
â”œâ”€â”€ productos/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ app.py
â”œâ”€â”€ usuarios/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ app.py
â””â”€â”€ pagos/
    â”œâ”€â”€ Dockerfile
    â””â”€â”€ app.py
```

---

## ğŸ Paso 2: Servicio de Productos

**Archivo:** `productos/app.py`
```python
from flask import Flask, jsonify
app = Flask(__name__)

@app.route('/productos')
def get_productos():
    return jsonify({
        "servicio": "productos",
        "productos": [
            {"id": 1, "nombre": "Laptop", "precio": 1200},
            {"id": 2, "nombre": "Mouse", "precio": 25}
        ]
    })

@app.route('/health')
def health():
    return jsonify({"status": "OK", "servicio": "productos"})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
```

---

## ğŸ Paso 2: Dockerfile para Productos

**Archivo:** `productos/Dockerfile`
```dockerfile
FROM python:3.9-slim
WORKDIR /app
RUN pip install flask
COPY app.py .
EXPOSE 80
CMD ["python", "app.py"]
```

**Repite este proceso para `usuarios` y `pagos`** cambiando:
- Usuarios: endpoint `/usuarios`, datos de usuarios
- Pagos: endpoint `/pagos`, datos de transacciones

---

## ğŸŒ Paso 3: Configurar Nginx

**Archivo:** `nginx/nginx.conf`
```nginx
events {
    worker_connections 1024;
}

http {
    upstream productos {
        server productos:80;
    }
    upstream usuarios {
        server usuarios:80;
    }
    upstream pagos {
        server pagos:80;
    }
    server {
        listen 80;
        location /api/productos {
            proxy_pass http://productos/productos;
        }
        location /api/usuarios {
            proxy_pass http://usuarios/usuarios;
        }
        location /api/pagos {
            proxy_pass http://pagos/pagos;
        }
        location /health {
            return 200 "Gateway OK";
        }
    }
}
```

---

## ğŸ³ Paso 4: Docker Compose

**Archivo:** `docker-compose.yml`
```yaml
version: '3.8'
services:
  productos:
    build: ./productos
    container_name: productos-service
    networks:
      - tienda-network
  usuarios:
    build: ./usuarios
    container_name: usuarios-service
    networks:
      - tienda-network
  pagos:
    build: ./pagos
    container_name: pagos-service
    networks:
      - tienda-network
  gateway:
    image: nginx
    container_name: api-gateway
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - productos
      - usuarios
      - pagos
    networks:
      - tienda-network
networks:
  tienda-network:
    driver: bridge
```

---

## ğŸš€ Paso 5: Ejecutar la PrÃ¡ctica

1. **Navegar al directorio:**
   ```bash
   cd mitienda
   ```

2. **Construir y ejecutar:**
   ```bash
   docker-compose up --build
   ```

3. **Probar los endpoints:**
   ```bash
   curl http://localhost/api/productos
   curl http://localhost/api/usuarios
   curl http://localhost/api/pagos
   ```

---

## ğŸ” Paso 6: VerificaciÃ³n

### Endpoints esperados:
- `http://localhost/api/productos` â†’ Lista de productos
- `http://localhost/api/usuarios` â†’ Lista de usuarios
- `http://localhost/api/pagos` â†’ Lista de transacciones
- `http://localhost/health` â†’ Estado del gateway

### Verificar contenedores:
```bash
docker-compose ps
docker-compose logs productos
```

---

## ğŸ“ Preguntas de ReflexiÃ³n

1. **Â¿QuÃ© patrÃ³n PoSA implementamos?**
   <!-- - Functional Decomposition (servicios por dominio)
   - Reverse Proxy Routing (enrutamiento centralizado) -->
2. **Â¿QuÃ© beneficios observas?**
   <!-- - Cada servicio es independiente
   - Se puede escalar por separado
   - Un punto de entrada unificado -->
3. **Â¿QuÃ© desafÃ­os identificas?**
   <!-- - ConfiguraciÃ³n de red
   - Debugging distribuido
   - GestiÃ³n de dependencias -->
---

## ğŸ† DesafÃ­o Extra (Opcional)

### Implementar Resource-Aware Placement:

```yaml
# En docker-compose.yml, agregar lÃ­mites
productos:
  build: ./productos
  deploy:
    resources:
      limits:
        cpus: '0.5'
        memory: 256M
```

### Simular Locality-Aware Placement:

```yaml
# Crear redes separadas para simular regiones
networks:
  region-us:
  region-eu:
```

---

## ğŸ“Š Entregables

1. **Captura de pantalla** de los endpoints funcionando
2. **Archivo docker-compose.yml** completo
3. **Respuestas** a las preguntas de reflexiÃ³n
4. **(Opcional)** ImplementaciÃ³n del desafÃ­o extra

**Tiempo estimado:** 45-60 minutos

---

## ğŸ’¡ Pensamiento para implementaciones futuras

> No es parte del ejercicio, pero pueden pensar en trabajo futuro

- Agregar base de datos (PostgreSQL/MongoDB)
- Implementar Service Discovery
- Agregar monitoreo con Prometheus
- Implementar circuit breakers
- Usar Kubernetes en lugar de Docker Compose
