---
title:   "Diseño de Arquitectura"
subtitle: "Patrones de diseño"
format:
  kotlin-quarto-revealjs-theme-revealjs:
    incremental: true
    footer: "Universidad CENFOTEC ©"
    logo: imgs/logo.png
author:
    - name: Kevin A. Hernández Rostrán
      degrees:
        - M.Sc.
      orcid: 0009-0001-7682-0350
      email: khernandez@ucenfotec.ac.cr
      affiliation:
        - name: Universidad Cenfotec
          url: https://ucenfotec.ac.cr/
---

## 💭 Introducción

> *"Cada patrón describe un problema que ocurre una y otra vez en nuestro entorno, y luego describe el núcleo de la solución a ese problema, de tal manera que puedes usar esta solución un millón de veces sin hacerlo de la misma forma dos veces."*

**— Christopher Alexander, Arquitecto**

---

## 🎯 Objetivos de la sesión

- Comprender los **patrones de diseño GoF** y sus categorías
- Implementar patrones **Creacionales, Estructurales y De Comportamiento**
- Conocer los **patrones arquitectónicos PoSA**
- Aplicar patrones usando **Docker** en proyectos reales
- Identificar **cuándo y cómo** usar cada patrón

---

## 📚 ¿Qué son los Patrones de Diseño?

> Los **patrones de diseño** son soluciones reutilizables a problemas comunes en el diseño de software.

### ✅ Beneficios:
- **Reutilización** - Soluciones probadas y documentadas
- **Comunicación** - Vocabulario común entre desarrolladores
- **Mantenibilidad** - Código más estructurado y comprensible
- **Escalabilidad** - Arquitecturas más flexibles

---

## 📚 ¿Qué son los Patrones de Diseño?

### 📖 Dos categorías principales:
1. **Patrones de Diseño (GoF)** - Nivel de código/clases
2. **Patrones Arquitectónicos (PoSA)** - Nivel de sistema/aplicación

---

# 🎩 Patrones GoF
## Gang of Four Design Patterns

---

## 📖 Contexto: Patrones GoF

**The Gang of Four (GoF)** son un conjunto de patrones de diseño para desarrollo de software orientado a objetos, descritos por primera vez en el libro *"Design Patterns: Elements of Reusable Object-Oriented Software"*.

**Autores:** Erich Gamma, Richard Helm, Ralph Johnson, y John Vlissides

**Año:** 1994 - ¡Casi 30 años y siguen siendo relevantes!

---

## 🗂️ Categorías de Patrones GoF

Los patrones GoF se dividen en **3 categorías principales**:

| Categoría | Propósito | Enfoque |
|-----------|-----------|---------|
| **🏗️ Creacionales** | **Cómo** crear objetos | Creación de instancias |
| **🔗 Estructurales** | **Cómo** componer objetos | Composición de clases/objetos |
| **🎭 De Comportamiento** | **Cómo** interactúan objetos | Comunicación entre objetos |

---

## 🏗️ Patrones Creacionales

### Objetivo: Controlar la **creación de objetos**

**Problema:** Crear objetos directamente puede crear dependencias y rigidez.

**Solución:** Abstraer el proceso de creación de objetos.

---

## 🏗️ Patrones Creacionales - Lista

| Patrón | Propósito |
|--------|-----------|
| **Singleton** | Una sola instancia en toda la aplicación |
| **Factory Method** | Crear objetos sin especificar clase exacta |
| **Abstract Factory** | Crear familias de objetos relacionados |
| **Builder** | Construir objetos complejos paso a paso |
| **Prototype** | Crear objetos clonando instancias existentes |

---

### 🎯 Ejemplo: Singleton Pattern

**Problema:** Necesito una sola instancia de configuración en toda la app.

```csharp
public sealed class ConfigManager
{
  private static ConfigManager _instance = null;
  private static readonly object _lock = new object();
  private Dictionary<string, string> _config;

  private ConfigManager()
  {
    _config = new Dictionary<string, string>
    {
      {"DatabaseUrl", "localhost:5432"},
      {"ApiKey", "abc123"}
    };
  }

  public static ConfigManager Instance
  {
    get
    {
      if (_instance == null)
      {
        lock (_lock)
        {
          if (_instance == null)
            _instance = new ConfigManager();
        }
      }
      return _instance;
    }
  }

  public string GetConfig(string key) => _config.GetValueOrDefault(key);
}
```

---

### 🎯 Ejemplo: Singleton Pattern

**Uso:**
```csharp
var config = ConfigManager.Instance;
string dbUrl = config.GetConfig("DatabaseUrl");
```

---

### 🎯 Ejemplo: Factory Method Pattern

**Problema:** Crear diferentes tipos de notificaciones sin acoplar código.

```csharp
// Producto abstracto
public abstract class Notification
{
  public abstract void Send(string message);
}

// Productos concretos
public class EmailNotification : Notification
{
  public override void Send(string message)
    => Console.WriteLine($"📧 Email: {message}");
}

public class SMSNotification : Notification
{
  public override void Send(string message)
    => Console.WriteLine($"📱 SMS: {message}");
}

// Factory
public abstract class NotificationFactory
{
  public abstract Notification CreateNotification();
}

public class EmailFactory : NotificationFactory
{
  public override Notification CreateNotification()
    => new EmailNotification();
}

// Uso
var factory = new EmailFactory();
var notification = factory.CreateNotification();
notification.Send("¡Hola mundo!");
```

---

## 🔗 Patrones Estructurales

### Objetivo: **Componer objetos** para formar estructuras más grandes

**Problema:** Necesito que objetos incompatibles trabajen juntos.

**Solución:** Proporcionar formas de componer objetos manteniendo flexibilidad.

---

## 🔗 Patrones Estructurales - Lista

| Patrón | Propósito |
|--------|-----------|
| **Adapter** | Hacer compatibles interfaces incompatibles |
| **Bridge** | Separar abstracción de implementación |
| **Composite** | Componer objetos en estructuras tipo árbol |
| **Decorator** | Agregar funcionalidad dinámicamente |
| **Facade** | Interfaz simple para subsistema complejo |
| **Flyweight** | Compartir eficientemente objetos similares |
| **Proxy** | Placeholder o representante de otro objeto |

---

### 🎯 Ejemplo: Adapter Pattern

**Problema:** Sistema legacy con interfaz incompatible.

```csharp
// Servicio legacy (no podemos modificar)
public class LegacyPaymentSystem
{
    public void ProcessLegacyPayment(string cardNumber, double amount)
    {
        Console.WriteLine($"Legacy: Processing ${amount} from card {cardNumber}");
    }
}

// Nueva interfaz que queremos usar
public interface IPaymentProcessor
{
    void ProcessPayment(PaymentRequest request);
}

// Adapter que hace compatible el sistema legacy
public class PaymentAdapter : IPaymentProcessor
{
    private LegacyPaymentSystem _legacySystem;

    public PaymentAdapter(LegacyPaymentSystem legacySystem)
    {
        _legacySystem = legacySystem;
    }

    public void ProcessPayment(PaymentRequest request)
    {
        // Adaptamos la nueva interfaz a la legacy
        _legacySystem.ProcessLegacyPayment(
            request.CardNumber,
            request.Amount
        );
    }
}

// Uso
var legacySystem = new LegacyPaymentSystem();
IPaymentProcessor processor = new PaymentAdapter(legacySystem);
processor.ProcessPayment(new PaymentRequest
{
    CardNumber = "1234-5678",
    Amount = 100.50
});
```

---

### 🎯 Ejemplo: Decorator Pattern

**Problema:** Agregar funcionalidades a objetos dinámicamente.

```csharp
// Componente base
public interface ICoffee
{
    string GetDescription();
    double GetCost();
}

// Implementación concreta
public class SimpleCoffee : ICoffee
{
    public string GetDescription() => "Café simple";
    public double GetCost() => 2.00;
}

// Decorator base
public abstract class CoffeeDecorator : ICoffee
{
    protected ICoffee _coffee;

    public CoffeeDecorator(ICoffee coffee)
    {
        _coffee = coffee;
    }

    public virtual string GetDescription() => _coffee.GetDescription();
    public virtual double GetCost() => _coffee.GetCost();
}

// Decorators concretos
public class MilkDecorator : CoffeeDecorator
{
    public MilkDecorator(ICoffee coffee) : base(coffee) { }

    public override string GetDescription()
        => _coffee.GetDescription() + ", Leche";
    public override double GetCost()
        => _coffee.GetCost() + 0.50;
}

public class SugarDecorator : CoffeeDecorator
{
    public SugarDecorator(ICoffee coffee) : base(coffee) { }

    public override string GetDescription()
        => _coffee.GetDescription() + ", Azúcar";
    public override double GetCost()
        => _coffee.GetCost() + 0.25;
}

// Uso: construir café dinámicamente
ICoffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);

Console.WriteLine($"{coffee.GetDescription()}: ${coffee.GetCost()}");
// Output: "Café simple, Leche, Azúcar: $2.75"
```

---

## 🎭 Patrones De Comportamiento

### Objetivo: **Comunicación y responsabilidades** entre objetos

**Problema:** Objetos necesitan interactuar de forma flexible y mantenible.

**Solución:** Definir cómo los objetos colaboran y se comunican.

---

## 🎭 Patrones De Comportamiento - Lista

| Patrón | Propósito |
|--------|-----------|
| **Observer** | Notificar cambios a múltiples objetos |
| **Strategy** | Intercambiar algoritmos dinámicamente |
| **Command** | Encapsular solicitudes como objetos |
| **State** | Cambiar comportamiento según estado interno |
| **Template Method** | Definir algoritmo base, customizar pasos |
| **Chain of Responsibility** | Pasar solicitudes por cadena de handlers |
| **Visitor** | Separar algoritmos de estructuras |
| **Mediator** | Mediar comunicación entre objetos |

---

### 🎯 Ejemplo: Observer Pattern

**Problema:** Múltiples objetos necesitan reaccionar a cambios de estado.

```csharp
// Subject (Observable)
public interface ISubject
{
    void Attach(IObserver observer);
    void Detach(IObserver observer);
    void Notify();
}

// Observer
public interface IObserver
{
    void Update(ISubject subject);
}

// Subject concreto
public class WeatherStation : ISubject
{
    private List<IObserver> _observers = new List<IObserver>();
    private float _temperature;

    public float Temperature
    {
        get { return _temperature; }
        set
        {
            _temperature = value;
            Notify(); // Notificar cuando cambia
        }
    }

    public void Attach(IObserver observer)
        => _observers.Add(observer);

    public void Detach(IObserver observer)
        => _observers.Remove(observer);

    public void Notify()
    {
        foreach (var observer in _observers)
            observer.Update(this);
    }
}

// Observers concretos
public class PhoneDisplay : IObserver
{
    public void Update(ISubject subject)
    {
        if (subject is WeatherStation station)
            Console.WriteLine($"📱 Teléfono: Temperatura {station.Temperature}°C");
    }
}

public class WebDisplay : IObserver
{
    public void Update(ISubject subject)
    {
        if (subject is WeatherStation station)
            Console.WriteLine($"🌐 Web: Temperatura {station.Temperature}°C");
    }
}

// Uso
var weatherStation = new WeatherStation();
var phoneDisplay = new PhoneDisplay();
var webDisplay = new WebDisplay();

weatherStation.Attach(phoneDisplay);
weatherStation.Attach(webDisplay);

weatherStation.Temperature = 25.5f;
// Output:
// 📱 Teléfono: Temperatura 25.5°C
// 🌐 Web: Temperatura 25.5°C
```

---

### 🎯 Ejemplo: Strategy Pattern

**Problema:** Diferentes algoritmos para la misma tarea.

```csharp
// Estrategia
public interface IPaymentStrategy
{
    void Pay(double amount);
}

// Estrategias concretas
public class CreditCardStrategy : IPaymentStrategy
{
    private string _cardNumber;

    public CreditCardStrategy(string cardNumber)
    {
        _cardNumber = cardNumber;
    }

    public void Pay(double amount)
    {
        Console.WriteLine($"💳 Pagando ${amount} con tarjeta {_cardNumber}");
    }
}

public class PayPalStrategy : IPaymentStrategy
{
    private string _email;

    public PayPalStrategy(string email)
    {
        _email = email;
    }

    public void Pay(double amount)
    {
        Console.WriteLine($"🏦 Pagando ${amount} con PayPal ({_email})");
    }
}

// Contexto
public class ShoppingCart
{
    private IPaymentStrategy _paymentStrategy;

    public void SetPaymentStrategy(IPaymentStrategy strategy)
    {
        _paymentStrategy = strategy;
    }

    public void Checkout(double amount)
    {
        _paymentStrategy?.Pay(amount);
    }
}

// Uso
var cart = new ShoppingCart();

// Pagar con tarjeta
cart.SetPaymentStrategy(new CreditCardStrategy("1234-5678"));
cart.Checkout(99.99);

// Cambiar a PayPal
cart.SetPaymentStrategy(new PayPalStrategy("user@email.com"));
cart.Checkout(99.99);
```

---

## 🎯 Resumen: ¿Cuándo usar cada categoría?

| Situación | Categoría | Ejemplo |
|-----------|-----------|---------|
| **Controlar creación de objetos** | 🏗️ Creacional | Una sola instancia de DB → Singleton |
| **Interfaces incompatibles** | 🔗 Estructural | API legacy → Adapter |
| **Algoritmos intercambiables** | 🎭 Comportamental | Métodos de pago → Strategy |
| **Notificar cambios** | 🎭 Comportamental | UI updates → Observer |
| **Agregar funcionalidad** | 🔗 Estructural | Personalizar café → Decorator |

---

## 🌉 Transición: De GoF a PoSA

### 🏗️ **Patrones GoF** (Nivel de código)
- **Alcance:** Clases y objetos individuales
- **Problema:** Cómo crear, estructurar y hacer interactuar objetos
- **Ejemplos:** Singleton, Factory, Observer, Strategy

### 🏛️ **Patrones PoSA** (Nivel arquitectónico)
- **Alcance:** Sistemas completos y aplicaciones distribuidas
- **Problema:** Cómo estructurar aplicaciones escalables y confiables
- **Ejemplos:** Microservicios, Load Balancing, Service Discovery

**💡 Ambos se complementan:** GoF para implementar componentes, PoSA para conectarlos.

---

# 🏛️ Patrones PoSA
## Patterns of Scalable, Reliable Services

---

## 💭 Introducción PoSA

> *"En un mundo donde la escala y la confiabilidad son requisitos, no características opcionales, los patrones arquitectónicos se convierten en el lenguaje común que permite a los equipos construir sistemas verdaderamente resilientes."*

**— Kevin Hoffman, Patterns of Scalable, Reliable Services**

---

## Patrones PoSA
### Arquitectura de Software Orientada a Patrones

Los patrones PoSA ofrecen soluciones reutilizables y probadas para diseñar sistemas de software **escalables, modulares y adaptables**.

Basado en:
📘 *Patterns of Scalable, Reliable Services*
👨‍💻 Autor: Kevin Hoffman

---

## Categorías de Patrones PoSA

Los patrones se agrupan en 4 categorías principales:

1. **Partitioning Patterns** – Dividir el sistema en partes manejables
2. **Placement Patterns** – Dónde desplegar o ubicar componentes
3. **Routing Patterns** – Cómo enrutar solicitudes y mensajes
4. **Federation Patterns** – Cómo colaborar entre múltiples instancias o dominios

---

## Partitioning Patterns
### Divide y vencerás

Estos patrones ayudan a dividir el sistema en **partes independientes** para mejorar el escalamiento, el mantenimiento y la resiliencia.

---

## 🎯 Contexto: Partitioning Patterns

### ¿Cuándo usar?
- Sistemas **monolíticos** que necesitan escalar
- Equipos **grandes** que necesitan trabajar independientemente
- Diferentes **cargas de trabajo** con requisitos distintos

### ✅ Beneficios:
- **Escalabilidad independiente** - cada parte se escala según su demanda
- **Desarrollo paralelo** - equipos pueden trabajar sin interferir
- **Tolerancia a fallos** - falla una parte, el resto sigue funcionando
- **Tecnologías especializadas** - cada parte usa la tecnología más apropiada

---

## 🎯 Contexto: Partitioning Patterns

### ⚠️ Desafíos:
- **Complejidad de red** - más comunicación entre servicios
- **Gestión de datos** - consistencia entre particiones
- **Monitoreo distribuido** - visibilidad del sistema completo

---

### Patrón: Functional Decomposition

Divide un sistema por **dominios funcionales**.
Ejemplo: usuarios, pagos, pedidos.

```{.yml .code-block}
## docker-compose.yaml
version: "3.8"
services:
  usuarios:
    image: miapp/usuarios
    ports:
      - "8081:80"
  pagos:
    image: miapp/pagos
    ports:
      - "8082:80"
  pedidos:
    image: miapp/pedidos
    ports:
      - "8083:80"
```

➡️ Cada servicio se puede desarrollar, desplegar y escalar por separado.

---

### Patrón: Data Partitioning (Sharding)

Divide los datos entre múltiples instancias.

```{.yml .code-block}
## docker-compose.yaml simulando sharding
version: "3.8"
services:
  db-shard-1:
    image: mongo
    ports:
      - "27017:27017"
    environment:
      - SHARD_ID=shard1

  db-shard-2:
    image: mongo
    ports:
      - "27018:27017"
    environment:
      - SHARD_ID=shard2
```

📌 Cada contenedor actúa como una partición de datos.

---

## Placement Patterns
### ¿Dónde ubicar componentes?

Estos patrones definen **dónde ejecutar cada componente**, según cercanía o capacidad del entorno.

---

## 🎯 Contexto: Placement Patterns

### ¿Cuándo usar?
- **Latencia** es crítica para la experiencia del usuario
- Recursos **limitados** que deben optimizarse
- **Regulaciones** requieren datos en ubicaciones específicas
- **Costos** de infraestructura deben minimizarse

### ✅ Beneficios:
- **Menor latencia** - servicios cerca del usuario final
- **Optimización de recursos** - usar la capacidad disponible eficientemente
- **Cumplimiento regulatorio** - datos en jurisdicciones correctas
- **Reducción de costos** - usar recursos más baratos cuando sea posible

---

## 🎯 Contexto: Placement Patterns

### ⚠️ Desafíos:
- **Gestión compleja** - múltiples ubicaciones para administrar
- **Sincronización** - mantener consistencia entre ubicaciones
- **Failover** - qué hacer cuando una ubicación falla

---

### Patrón: Locality-Aware Placement

Ubica los servicios **cerca del consumidor final**.

```{.yml .code-block}
## docker-compose con redes separadas
networks:
  zona_eu:
  zona_us:

services:
  servicio-eu:
    image: miapp/app
    networks:
      - zona_eu

  servicio-us:
    image: miapp/app
    networks:
      - zona_us
```

🌍 Esto permite simular regiones o zonas geográficas locales.

---

### Patrón: Resource-Aware Placement

Ejecuta servicios según requisitos de recursos.

```{.yml .code-block}
## Ejecutar con límites de recursos
docker run -d   --memory="512m"   --cpus="0.5"   --name servicio-ligero   miapp/app
```

⚖️ Este patrón optimiza el uso de recursos disponibles en el host.

---

## Routing Patterns
### ¿Cómo se enrutan las solicitudes?

Estos patrones definen **cómo dirigir el tráfico** hacia los servicios apropiados.

---

## 🎯 Contexto: Routing Patterns

### ¿Cuándo usar?
- **Múltiples versiones** del mismo servicio en producción
- **Balanceador de carga** necesario para distribuir tráfico
- **A/B testing** o **canary deployments** requeridos
- **Servicios especializados** según tipo de solicitud

### ✅ Beneficios:
- **Flexibilidad de despliegue** - dirigir tráfico según necesidades
- **Zero-downtime deployments** - cambiar versiones sin interrupciones
- **Testing en producción** - probar nuevas funcionalidades gradualmente
- **Optimización de rendimiento** - enrutar según capacidad o latencia

---

## 🎯 Contexto: Routing Patterns

### ⚠️ Desafíos:
- **Punto de falla único** - el router puede ser crítico
- **Configuración compleja** - reglas de enrutamiento pueden ser complicadas
- **Observabilidad** - rastrear flujo de solicitudes entre servicios

---

### Patrón: Client-Side Routing

El cliente decide a qué endpoint conectarse.

```{.yml .code-block}
## JavaScript (cliente)
const region = detectUserRegion();
const url = region === 'EU'
  ? 'http://localhost:8081'
  : 'http://localhost:8082';

fetch(url + '/status');
```

📍 Útil para enrutar según región u origen de usuario.

---

### Patrón: Reverse Proxy Routing

Un proxy enruta el tráfico según el path o encabezados.

```{.yml .code-block}
## docker-compose con Nginx como reverse proxy
version: "3.8"
services:
  proxy:
    image: nginx
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    ports:
      - "80:80"

  pagos:
    image: miapp/pagos
    ports:
      - "8082:80"

  usuarios:
    image: miapp/usuarios
    ports:
      - "8081:80"
```

📬 Nginx actúa como punto central de enrutamiento.

---

## Federation Patterns
### Colaboración entre dominios o clusters

Permiten que múltiples sistemas trabajen en conjunto sin perder autonomía.

---

## 🎯 Contexto: Federation Patterns

### ¿Cuándo usar?
- **Múltiples organizaciones** necesitan colaborar
- **Sistemas legacy** deben integrarse con modernos
- **Microservicios** necesitan compartir funcionalidades comunes
- **Multi-cloud** o **híbrido** deployments

### ✅ Beneficios:
- **Autonomía preservada** - cada dominio mantiene independencia
- **Reutilización** - servicios compartidos entre dominios
- **Interoperabilidad** - sistemas diferentes pueden colaborar
- **Gobernanza distribuida** - cada equipo controla su dominio

---

## 🎯 Contexto: Federation Patterns

### ⚠️ Desafíos:
- **Contratos de API** - mantener compatibilidad entre dominios
- **Seguridad compleja** - autenticación y autorización cross-domain
- **Debugging distribuido** - problemas pueden cruzar múltiples dominios
- **Versionado** - coordinar cambios entre múltiples equipos

---

### Patrón: Service Federation

Simula consumir servicios externos desde otro entorno o red.

```{.yml .code-block}
## docker-compose con ExternalName simulado usando proxy
version: "3.8"
services:
  proxy:
    image: nginx
    volumes:
      - ./nginx-externo.conf:/etc/nginx/nginx.conf
    ports:
      - "8080:80"

  servicio-local:
    image: miapp/local
    ports:
      - "8085:80"
```

🔗 El proxy actúa como puente a servicios federados externos.

---

### Patrón: Shared Identity

Múltiples servicios usan el mismo proveedor de identidad.

```{.yml .code-block}
## docker-compose con servicio que consume OIDC
version: "3.8"
services:
  servicio:
    image: miapp/secure-app
    environment:
      - OIDC_ISSUER=https://login.empresa.com
```

🔐 Asegura una identidad común entre servicios distribuidos.

---

## Conclusión

✅ Los patrones PoSA ayudan a construir sistemas **modulares, escalables y mantenibles**.

🐳 Usando **Docker**, podemos implementar fácilmente estos patrones en entornos modernos.

📚 Más info: *Patterns of Scalable, Reliable Services* — Kevin Hoffman

---

## 🛠️ Práctica: Implementando Patrones PoSA

### Objetivo
Implementar **patrones PoSA** (Functional Decomposition + Reverse Proxy Routing) en un sistema de e-commerce.

---

## 📝 Paso 1: Estructura del Proyecto

Crear la siguiente estructura de carpetas:

```
mitienda/
├── docker-compose.yml
├── nginx/
│   └── nginx.conf
├── productos/
│   ├── Dockerfile
│   └── app.py
├── usuarios/
│   ├── Dockerfile
│   └── app.py
└── pagos/
    ├── Dockerfile
    └── app.py
```

---

## 🐍 Paso 2: Servicio de Productos

**Archivo:** `productos/app.py`
```python
from flask import Flask, jsonify
app = Flask(__name__)

@app.route('/productos')
def get_productos():
    return jsonify({
        "servicio": "productos",
        "productos": [
            {"id": 1, "nombre": "Laptop", "precio": 1200},
            {"id": 2, "nombre": "Mouse", "precio": 25}
        ]
    })

@app.route('/health')
def health():
    return jsonify({"status": "OK", "servicio": "productos"})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
```

---

## 🐍 Paso 2: Dockerfile para Productos

**Archivo:** `productos/Dockerfile`
```dockerfile
FROM python:3.9-slim
WORKDIR /app
RUN pip install flask
COPY app.py .
EXPOSE 80
CMD ["python", "app.py"]
```

**Repite este proceso para `usuarios` y `pagos`** cambiando:
- Usuarios: endpoint `/usuarios`, datos de usuarios
- Pagos: endpoint `/pagos`, datos de transacciones

---

## 🌐 Paso 3: Configurar Nginx

**Archivo:** `nginx/nginx.conf`
```nginx
events {
    worker_connections 1024;
}

http {
    upstream productos {
        server productos:80;
    }
    upstream usuarios {
        server usuarios:80;
    }
    upstream pagos {
        server pagos:80;
    }
    server {
        listen 80;
        location /api/productos {
            proxy_pass http://productos/productos;
        }
        location /api/usuarios {
            proxy_pass http://usuarios/usuarios;
        }
        location /api/pagos {
            proxy_pass http://pagos/pagos;
        }
        location /health {
            return 200 "Gateway OK";
        }
    }
}
```

---

## 🐳 Paso 4: Docker Compose

**Archivo:** `docker-compose.yml`
```yaml
version: '3.8'
services:
  productos:
    build: ./productos
    container_name: productos-service
    networks:
      - tienda-network
  usuarios:
    build: ./usuarios
    container_name: usuarios-service
    networks:
      - tienda-network
  pagos:
    build: ./pagos
    container_name: pagos-service
    networks:
      - tienda-network
  gateway:
    image: nginx
    container_name: api-gateway
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - productos
      - usuarios
      - pagos
    networks:
      - tienda-network
networks:
  tienda-network:
    driver: bridge
```

---

## 🚀 Paso 5: Ejecutar la Práctica

1. **Navegar al directorio:**
   ```bash
   cd mitienda
   ```

2. **Construir y ejecutar:**
   ```bash
   docker-compose up --build
   ```

3. **Probar los endpoints:**
   ```bash
   curl http://localhost/api/productos
   curl http://localhost/api/usuarios
   curl http://localhost/api/pagos
   ```

---

## 🔍 Paso 6: Verificación

### Endpoints esperados:
- `http://localhost/api/productos` → Lista de productos
- `http://localhost/api/usuarios` → Lista de usuarios
- `http://localhost/api/pagos` → Lista de transacciones
- `http://localhost/health` → Estado del gateway

### Verificar contenedores:
```bash
docker-compose ps
docker-compose logs productos
```

---

## 🎓 Preguntas de Reflexión

1. **¿Qué patrón PoSA implementamos?**
   <!-- - Functional Decomposition (servicios por dominio)
   - Reverse Proxy Routing (enrutamiento centralizado) -->
2. **¿Qué beneficios observas?**
   <!-- - Cada servicio es independiente
   - Se puede escalar por separado
   - Un punto de entrada unificado -->
3. **¿Qué desafíos identificas?**
   <!-- - Configuración de red
   - Debugging distribuido
   - Gestión de dependencias -->
---

## 🏆 Desafío Extra (Opcional)

### Implementar Resource-Aware Placement:

```yaml
# En docker-compose.yml, agregar límites
productos:
  build: ./productos
  deploy:
    resources:
      limits:
        cpus: '0.5'
        memory: 256M
```

### Simular Locality-Aware Placement:

```yaml
# Crear redes separadas para simular regiones
networks:
  region-us:
  region-eu:
```

---

## 📊 Entregables

1. **Captura de pantalla** de los endpoints funcionando
2. **Archivo docker-compose.yml** completo
3. **Respuestas** a las preguntas de reflexión
4. **(Opcional)** Implementación del desafío extra

**Tiempo estimado:** 45-60 minutos

---

## 💡 Pensamiento para implementaciones futuras

> No es parte del ejercicio, pero pueden pensar en trabajo futuro

- Agregar base de datos (PostgreSQL/MongoDB)
- Implementar Service Discovery
- Agregar monitoreo con Prometheus
- Implementar circuit breakers
- Usar Kubernetes en lugar de Docker Compose
