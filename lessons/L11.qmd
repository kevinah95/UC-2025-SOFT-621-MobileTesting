---
title:   "DiseÃ±o de IngenierÃ­a"
subtitle: "DiseÃ±o de Arquitectura"
format:
  kotlin-quarto-revealjs-theme-revealjs:
    incremental: true
    footer: "Universidad CENFOTEC Â©"
    logo: imgs/logo.png
author:
    - name: Kevin A. HernÃ¡ndez RostrÃ¡n
      degrees:
        - M.Sc.
      orcid: 0009-0001-7682-0350
      email: khernandez@ucenfotec.ac.cr
      affiliation:
        - name: Universidad Cenfotec
          url: https://ucenfotec.ac.cr/
---

## ğŸ’­ IntroducciÃ³n

> *"En un mundo donde la escala y la confiabilidad son requisitos, no caracterÃ­sticas opcionales, los patrones arquitectÃ³nicos se convierten en el lenguaje comÃºn que permite a los equipos construir sistemas verdaderamente resilientes."*

**â€” Kevin Hoffman, Patterns of Scalable, Reliable Services**

---

## Patrones PoSA
### Arquitectura de Software Orientada a Patrones

Los patrones PoSA ofrecen soluciones reutilizables y probadas para diseÃ±ar sistemas de software **escalables, modulares y adaptables**.

Basado en:
ğŸ“˜ *Patterns of Scalable, Reliable Services*
ğŸ‘¨â€ğŸ’» Autor: Kevin Hoffman

---

## CategorÃ­as de Patrones PoSA

Los patrones se agrupan en 4 categorÃ­as principales:

1. **Partitioning Patterns** â€“ Dividir el sistema en partes manejables
2. **Placement Patterns** â€“ DÃ³nde desplegar o ubicar componentes
3. **Routing Patterns** â€“ CÃ³mo enrutar solicitudes y mensajes
4. **Federation Patterns** â€“ CÃ³mo colaborar entre mÃºltiples instancias o dominios

---

## Partitioning Patterns
### Divide y vencerÃ¡s

Estos patrones ayudan a dividir el sistema en **partes independientes** para mejorar el escalamiento, el mantenimiento y la resiliencia.

---

## ğŸ¯ Contexto: Partitioning Patterns

### Â¿CuÃ¡ndo usar?
- Sistemas **monolÃ­ticos** que necesitan escalar
- Equipos **grandes** que necesitan trabajar independientemente
- Diferentes **cargas de trabajo** con requisitos distintos

### âœ… Beneficios:
- **Escalabilidad independiente** - cada parte se escala segÃºn su demanda
- **Desarrollo paralelo** - equipos pueden trabajar sin interferir
- **Tolerancia a fallos** - falla una parte, el resto sigue funcionando
- **TecnologÃ­as especializadas** - cada parte usa la tecnologÃ­a mÃ¡s apropiada

---

## ğŸ¯ Contexto: Partitioning Patterns

### âš ï¸ DesafÃ­os:
- **Complejidad de red** - mÃ¡s comunicaciÃ³n entre servicios
- **GestiÃ³n de datos** - consistencia entre particiones
- **Monitoreo distribuido** - visibilidad del sistema completo

---

### PatrÃ³n: Functional Decomposition

Divide un sistema por **dominios funcionales**.
Ejemplo: usuarios, pagos, pedidos.

```{.yml .code-block}
## docker-compose.yaml
version: "3.8"
services:
  usuarios:
    image: miapp/usuarios
    ports:
      - "8081:80"
  pagos:
    image: miapp/pagos
    ports:
      - "8082:80"
  pedidos:
    image: miapp/pedidos
    ports:
      - "8083:80"
```

â¡ï¸ Cada servicio se puede desarrollar, desplegar y escalar por separado.

---

### PatrÃ³n: Data Partitioning (Sharding)

Divide los datos entre mÃºltiples instancias.

```{.yml .code-block}
## docker-compose.yaml simulando sharding
version: "3.8"
services:
  db-shard-1:
    image: mongo
    ports:
      - "27017:27017"
    environment:
      - SHARD_ID=shard1

  db-shard-2:
    image: mongo
    ports:
      - "27018:27017"
    environment:
      - SHARD_ID=shard2
```

ğŸ“Œ Cada contenedor actÃºa como una particiÃ³n de datos.

---

## Placement Patterns
### Â¿DÃ³nde ubicar componentes?

Estos patrones definen **dÃ³nde ejecutar cada componente**, segÃºn cercanÃ­a o capacidad del entorno.

---

## ğŸ¯ Contexto: Placement Patterns

### Â¿CuÃ¡ndo usar?
- **Latencia** es crÃ­tica para la experiencia del usuario
- Recursos **limitados** que deben optimizarse
- **Regulaciones** requieren datos en ubicaciones especÃ­ficas
- **Costos** de infraestructura deben minimizarse

### âœ… Beneficios:
- **Menor latencia** - servicios cerca del usuario final
- **OptimizaciÃ³n de recursos** - usar la capacidad disponible eficientemente
- **Cumplimiento regulatorio** - datos en jurisdicciones correctas
- **ReducciÃ³n de costos** - usar recursos mÃ¡s baratos cuando sea posible

---

## ğŸ¯ Contexto: Placement Patterns

### âš ï¸ DesafÃ­os:
- **GestiÃ³n compleja** - mÃºltiples ubicaciones para administrar
- **SincronizaciÃ³n** - mantener consistencia entre ubicaciones
- **Failover** - quÃ© hacer cuando una ubicaciÃ³n falla

---

### PatrÃ³n: Locality-Aware Placement

Ubica los servicios **cerca del consumidor final**.

```{.yml .code-block}
## docker-compose con redes separadas
networks:
  zona_eu:
  zona_us:

services:
  servicio-eu:
    image: miapp/app
    networks:
      - zona_eu

  servicio-us:
    image: miapp/app
    networks:
      - zona_us
```

ğŸŒ Esto permite simular regiones o zonas geogrÃ¡ficas locales.

---

### PatrÃ³n: Resource-Aware Placement

Ejecuta servicios segÃºn requisitos de recursos.

```{.yml .code-block}
## Ejecutar con lÃ­mites de recursos
docker run -d   --memory="512m"   --cpus="0.5"   --name servicio-ligero   miapp/app
```

âš–ï¸ Este patrÃ³n optimiza el uso de recursos disponibles en el host.

---

## Routing Patterns
### Â¿CÃ³mo se enrutan las solicitudes?

Estos patrones definen **cÃ³mo dirigir el trÃ¡fico** hacia los servicios apropiados.

---

## ğŸ¯ Contexto: Routing Patterns

### Â¿CuÃ¡ndo usar?
- **MÃºltiples versiones** del mismo servicio en producciÃ³n
- **Balanceador de carga** necesario para distribuir trÃ¡fico
- **A/B testing** o **canary deployments** requeridos
- **Servicios especializados** segÃºn tipo de solicitud

### âœ… Beneficios:
- **Flexibilidad de despliegue** - dirigir trÃ¡fico segÃºn necesidades
- **Zero-downtime deployments** - cambiar versiones sin interrupciones
- **Testing en producciÃ³n** - probar nuevas funcionalidades gradualmente
- **OptimizaciÃ³n de rendimiento** - enrutar segÃºn capacidad o latencia

---

## ğŸ¯ Contexto: Routing Patterns

### âš ï¸ DesafÃ­os:
- **Punto de falla Ãºnico** - el router puede ser crÃ­tico
- **ConfiguraciÃ³n compleja** - reglas de enrutamiento pueden ser complicadas
- **Observabilidad** - rastrear flujo de solicitudes entre servicios

---

### PatrÃ³n: Client-Side Routing

El cliente decide a quÃ© endpoint conectarse.

```{.yml .code-block}
## JavaScript (cliente)
const region = detectUserRegion();
const url = region === 'EU'
  ? 'http://localhost:8081'
  : 'http://localhost:8082';

fetch(url + '/status');
```

ğŸ“ Ãštil para enrutar segÃºn regiÃ³n u origen de usuario.

---

### PatrÃ³n: Reverse Proxy Routing

Un proxy enruta el trÃ¡fico segÃºn el path o encabezados.

```{.yml .code-block}
## docker-compose con Nginx como reverse proxy
version: "3.8"
services:
  proxy:
    image: nginx
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    ports:
      - "80:80"

  pagos:
    image: miapp/pagos
    ports:
      - "8082:80"

  usuarios:
    image: miapp/usuarios
    ports:
      - "8081:80"
```

ğŸ“¬ Nginx actÃºa como punto central de enrutamiento.

---

## Federation Patterns
### ColaboraciÃ³n entre dominios o clusters

Permiten que mÃºltiples sistemas trabajen en conjunto sin perder autonomÃ­a.

---

## ğŸ¯ Contexto: Federation Patterns

### Â¿CuÃ¡ndo usar?
- **MÃºltiples organizaciones** necesitan colaborar
- **Sistemas legacy** deben integrarse con modernos
- **Microservicios** necesitan compartir funcionalidades comunes
- **Multi-cloud** o **hÃ­brido** deployments

### âœ… Beneficios:
- **AutonomÃ­a preservada** - cada dominio mantiene independencia
- **ReutilizaciÃ³n** - servicios compartidos entre dominios
- **Interoperabilidad** - sistemas diferentes pueden colaborar
- **Gobernanza distribuida** - cada equipo controla su dominio

---

## ğŸ¯ Contexto: Federation Patterns

### âš ï¸ DesafÃ­os:
- **Contratos de API** - mantener compatibilidad entre dominios
- **Seguridad compleja** - autenticaciÃ³n y autorizaciÃ³n cross-domain
- **Debugging distribuido** - problemas pueden cruzar mÃºltiples dominios
- **Versionado** - coordinar cambios entre mÃºltiples equipos

---

### PatrÃ³n: Service Federation

Simula consumir servicios externos desde otro entorno o red.

```{.yml .code-block}
## docker-compose con ExternalName simulado usando proxy
version: "3.8"
services:
  proxy:
    image: nginx
    volumes:
      - ./nginx-externo.conf:/etc/nginx/nginx.conf
    ports:
      - "8080:80"

  servicio-local:
    image: miapp/local
    ports:
      - "8085:80"
```

ğŸ”— El proxy actÃºa como puente a servicios federados externos.

---

### PatrÃ³n: Shared Identity

MÃºltiples servicios usan el mismo proveedor de identidad.

```{.yml .code-block}
## docker-compose con servicio que consume OIDC
version: "3.8"
services:
  servicio:
    image: miapp/secure-app
    environment:
      - OIDC_ISSUER=https://login.empresa.com
```

ğŸ” Asegura una identidad comÃºn entre servicios distribuidos.

---

## ConclusiÃ³n

âœ… Los patrones PoSA ayudan a construir sistemas **modulares, escalables y mantenibles**.

ğŸ³ Usando **Docker**, podemos implementar fÃ¡cilmente estos patrones en entornos modernos.

ğŸ“š MÃ¡s info: *Patterns of Scalable, Reliable Services* â€” Kevin Hoffman

---

## ğŸ› ï¸ PrÃ¡ctica: Implementando Patrones PoSA

### Objetivo
Implementar **Functional Decomposition** y **Reverse Proxy Routing** para un sistema de e-commerce bÃ¡sico.

---

## ğŸ“‹ Requisitos Previos

- âœ… Docker y Docker Compose instalados
- âœ… Editor de texto (VS Code, Sublime, etc.)
- âœ… Navegador web
- âœ… Terminal/PowerShell

**Verificar instalaciÃ³n:**
```bash
docker --version
docker-compose --version
```

---

## ğŸ¯ Escenario: MiTienda Online

Vamos a crear un sistema de e-commerce con 3 microservicios:

1. **ğŸ›’ Servicio de Productos** - Puerto 8001
2. **ğŸ‘¤ Servicio de Usuarios** - Puerto 8002
3. **ğŸ’³ Servicio de Pagos** - Puerto 8003
4. **ğŸšª Gateway (Nginx)** - Puerto 80

**PatrÃ³n aplicado:** Functional Decomposition + Reverse Proxy Routing

---

## ğŸ“ Paso 1: Estructura del Proyecto

Crear la siguiente estructura de carpetas:

```
mitienda/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ nginx/
â”‚   â””â”€â”€ nginx.conf
â”œâ”€â”€ productos/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ app.py
â”œâ”€â”€ usuarios/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ app.py
â””â”€â”€ pagos/
    â”œâ”€â”€ Dockerfile
    â””â”€â”€ app.py
```

---

## ğŸ Paso 2: Servicio de Productos

**Archivo:** `productos/app.py`
```python
from flask import Flask, jsonify
app = Flask(__name__)

@app.route('/productos')
def get_productos():
    return jsonify({
        "servicio": "productos",
        "productos": [
            {"id": 1, "nombre": "Laptop", "precio": 1200},
            {"id": 2, "nombre": "Mouse", "precio": 25}
        ]
    })

@app.route('/health')
def health():
    return jsonify({"status": "OK", "servicio": "productos"})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
```

---

## ğŸ Paso 2: Dockerfile para Productos

**Archivo:** `productos/Dockerfile`
```dockerfile
FROM python:3.9-slim
WORKDIR /app
RUN pip install flask
COPY app.py .
EXPOSE 80
CMD ["python", "app.py"]
```

**Repite este proceso para `usuarios` y `pagos`** cambiando:
- Usuarios: endpoint `/usuarios`, datos de usuarios
- Pagos: endpoint `/pagos`, datos de transacciones

---

## ğŸŒ Paso 3: Configurar Nginx

**Archivo:** `nginx/nginx.conf`
```nginx
events {
    worker_connections 1024;
}

http {
    upstream productos {
        server productos:80;
    }

    upstream usuarios {
        server usuarios:80;
    }

    upstream pagos {
        server pagos:80;
    }

    server {
        listen 80;

        location /api/productos {
            proxy_pass http://productos/productos;
        }

        location /api/usuarios {
            proxy_pass http://usuarios/usuarios;
        }

        location /api/pagos {
            proxy_pass http://pagos/pagos;
        }

        location /health {
            return 200 "Gateway OK";
        }
    }
}
```

---

## ğŸ³ Paso 4: Docker Compose

**Archivo:** `docker-compose.yml`
```yaml
version: '3.8'
services:
  productos:
    build: ./productos
    container_name: productos-service
    networks:
      - tienda-network

  usuarios:
    build: ./usuarios
    container_name: usuarios-service
    networks:
      - tienda-network

  pagos:
    build: ./pagos
    container_name: pagos-service
    networks:
      - tienda-network

  gateway:
    image: nginx
    container_name: api-gateway
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - productos
      - usuarios
      - pagos
    networks:
      - tienda-network

networks:
  tienda-network:
    driver: bridge
```

---

## ğŸš€ Paso 5: Ejecutar la PrÃ¡ctica

1. **Navegar al directorio:**
   ```bash
   cd mitienda
   ```

2. **Construir y ejecutar:**
   ```bash
   docker-compose up --build
   ```

3. **Probar los endpoints:**
   ```bash
   curl http://localhost/api/productos
   curl http://localhost/api/usuarios
   curl http://localhost/api/pagos
   ```

---

## ğŸ” Paso 6: VerificaciÃ³n

### Endpoints esperados:
- `http://localhost/api/productos` â†’ Lista de productos
- `http://localhost/api/usuarios` â†’ Lista de usuarios
- `http://localhost/api/pagos` â†’ Lista de transacciones
- `http://localhost/health` â†’ Estado del gateway

### Verificar contenedores:
```bash
docker-compose ps
docker-compose logs productos
```

---

## ğŸ“ Preguntas de ReflexiÃ³n

1. **Â¿QuÃ© patrÃ³n PoSA implementamos?**
   - Functional Decomposition (servicios por dominio)
   - Reverse Proxy Routing (enrutamiento centralizado)

2. **Â¿QuÃ© beneficios observas?**
   - Cada servicio es independiente
   - Se puede escalar por separado
   - Un punto de entrada unificado

3. **Â¿QuÃ© desafÃ­os identificas?**
   - ConfiguraciÃ³n de red
   - Debugging distribuido
   - GestiÃ³n de dependencias

---

## ğŸ† DesafÃ­o Extra (Opcional)

### Implementar Resource-Aware Placement:

```yaml
# En docker-compose.yml, agregar lÃ­mites
productos:
  build: ./productos
  deploy:
    resources:
      limits:
        cpus: '0.5'
        memory: 256M
```

### Simular Locality-Aware Placement:

```yaml
# Crear redes separadas para simular regiones
networks:
  region-us:
  region-eu:
```

---

## ğŸ“Š Entregables

1. **Captura de pantalla** de los endpoints funcionando
2. **Archivo docker-compose.yml** completo
3. **Respuestas** a las preguntas de reflexiÃ³n
4. **(Opcional)** ImplementaciÃ³n del desafÃ­o extra

**Tiempo estimado:** 45-60 minutos

---

## ğŸ’¡ Extensiones Futuras

- Agregar base de datos (PostgreSQL/MongoDB)
- Implementar Service Discovery
- Agregar monitoreo con Prometheus
- Implementar circuit breakers
- Usar Kubernetes en lugar de Docker Compose
