---
title:   "DiseÃ±o de IngenierÃ­a"
subtitle: "DiseÃ±o de Arquitectura"
format:
  kotlin-quarto-revealjs-theme-revealjs:
    incremental: true
    footer: "Universidad CENFOTEC Â©"
    logo: imgs/logo.png
author:
    - name: Kevin A. HernÃ¡ndez RostrÃ¡n
      degrees:
        - M.Sc.
      orcid: 0009-0001-7682-0350
      email: khernandez@ucenfotec.ac.cr
      affiliation:
        - name: Universidad Cenfotec
          url: https://ucenfotec.ac.cr/
---


## Objetivos de la sesiÃ³n ğŸ¯

- Distinguir entre paradigmas de programaciÃ³n (estructurado, orientado a objetos, funcional).
- Comprender los 4 principios fundamentales de la POO (herencia, polimorfismo, abstracciÃ³n, encapsulamiento).
- Identificar y evitar code smells comunes en el diseÃ±o de software.
- Aplicar los 5 principios SOLID con ejemplos prÃ¡cticos en C#.
- Analizar ejemplos de programaciÃ³n funcional en Haskell y Elixir.
- Reflexionar sobre el impacto de SOLID en la mantenibilidad y calidad del software.

---

## ğŸ’­ Paradigmas de ProgramaciÃ³n

> Un **paradigma** es un enfoque o modelo mental para resolver problemas usando cÃ³digo.

---

## ğŸ¤” Â¿Por quÃ© importa el paradigma?

- Determina cÃ³mo organizamos el cÃ³digo.
- Influye en la mantenibilidad, flexibilidad y escalabilidad.
- Algunos lenguajes soportan mÃºltiples paradigmas (como C#, JavaScript, Python).

---

## ğŸ“‹ Paradigmas mÃ¡s comunes

| Paradigma              | Enfoque principal                                      |
|------------------------|--------------------------------------------------------|
| **Estructurado**       | Organizar cÃ³digo en secuencias, decisiones y ciclos.   |
| **Orientado a Objetos**| Modelar entidades del mundo real como objetos.         |
| **Funcional**          | Basado en funciones puras, sin estado mutable.         |

---

## ğŸŸ¦ ProgramaciÃ³n Estructurada

- Enfocada en **funciones y procedimientos** que procesan datos paso a paso.
- Usa estructuras de control: `if`, `while`, `for`, `switch`.
- Los datos y las funciones estÃ¡n **separados**.
- Evita el uso de *goto*, promoviendo bloques bien definidos.

---

## ğŸ’» Ejemplo en C - Procesamiento de estudiantes:

<!-- language: c -->
``` {.csharp .code-line-numbers}
#include <stdio.h>

struct Student {
    char name[50];
    int grade;
};

void printStudent(struct Student s) {
    printf("Estudiante: %s, Nota: %d\n", s.name, s.grade);
}

int calculateAverage(struct Student students[], int count) {
    int sum = 0;
    for (int i = 0; i < count; i++) {
        sum += students[i].grade;
    }
    return sum / count;
}
```

**Lenguajes:** C, Pascal, FORTRAN, COBOL

ğŸ§  Ideal para: algoritmos, sistemas embebidos, programaciÃ³n de sistemas.

---

## ğŸŸ© ProgramaciÃ³n Orientada a Objetos (POO)

- Organiza el cÃ³digo en **clases y objetos** que encapsulan datos y comportamiento.
- Usa **herencia, encapsulamiento, abstracciÃ³n y polimorfismo**.
- Los datos y mÃ©todos estÃ¡n **unidos** en la misma entidad.
- Permite modelar estructuras complejas y dominios reales.

---

## ğŸ’» Ejemplo en C\# - Sistema de estudiantes:

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class Student
{
    public string Name { get; set; }
    public int Grade { get; private set; }

    public void UpdateGrade(int newGrade)
    {
        if (newGrade >= 0 && newGrade <= 100)
            Grade = newGrade;
    }

    public void PrintInfo()
    {
        Console.WriteLine($"Estudiante: {Name}, Nota: {Grade}");
    }
}
```

**Lenguajes:** C#, Java, C++, Python, JavaScript

Veremos esto a profundidad en esta sesiÃ³n ğŸ‘‡

---

## ğŸŸª ProgramaciÃ³n Funcional

- Basada en **funciones puras** (sin efectos colaterales).
- **Inmutabilidad**: no se modifica el estado, se crean nuevas estructuras.
- **ComposiciÃ³n de funciones** como unidad principal.
- Evita bucles tradicionales, prefiere recursiÃ³n y funciones de orden superior.

---

## ğŸ’» Ejemplo en Haskell - Procesamiento de estudiantes:

<!-- language: haskell -->
``` {.haskell .code-line-numbers}
-- Definir el tipo de dato Student (nombre y nota)
data Student = Student String Int

-- FunciÃ³n para extraer la nota de un estudiante
studentGrade :: Student -> Int
studentGrade (Student _ grade) = grade  -- El _ ignora el nombre

-- Calcular promedio de notas
averageGrade :: [Student] -> Double
averageGrade students =
    fromIntegral (sum grades) / fromIntegral (length grades)
    where grades = map studentGrade students  -- map aplica la funciÃ³n a todos

-- Filtrar estudiantes que pasaron (nota >= 70)
passedStudents :: [Student] -> [Student]
passedStudents = filter (\s -> studentGrade s >= 70)  -- filter filtra por condiciÃ³n
```

---

## ğŸ’» Ejemplo en Elixir:

<!-- language: elixir -->
``` {.elixir .code-line-numbers}
defmodule StudentProcessor do
  # FunciÃ³n para calcular promedio
  def average_grade(students) do
    students
    |> Enum.map(& &1.grade)        # Extraer todas las notas
    |> Enum.sum()                  # Sumar todas las notas
    |> Kernel./(length(students))  # Dividir por cantidad de estudiantes
  end

  # FunciÃ³n para filtrar estudiantes aprobados
  def passed_students(students) do
    Enum.filter(students, & &1.grade >= 70)  # Filtrar por nota >= 70
  end
end
```

**Lenguajes:** Haskell, Elixir, F#, Clojure, Erlang, Scala

ğŸ§  Muy Ãºtil en sistemas concurrentes, reactivos, o de alto paralelismo.

---

## âš–ï¸ ComparaciÃ³n general

| Aspecto               | Estructurado       | POO                 | Funcional              |
|------------------------|--------------------|----------------------|-------------------------|
| **Unidad principal**   | Funciones/Procedimientos | Objetos              | Funciones puras         |
| **Estado**             | Global o local      | Encapsulado en objetos | Inmutable               |
| **Datos vs Comportamiento** | Separados        | Unidos en clases     | Funciones transforman datos |
| **Control de flujo**   | Secuencia/condiciÃ³n | InteracciÃ³n entre objetos | ComposiciÃ³n de funciones |
| **ReutilizaciÃ³n**      | Llamadas a funciones | Herencia/ComposiciÃ³n | Funciones de orden superior |
| **Ejemplo de lenguaje** | C, Pascal, COBOL   | C#, Java, Python     | Haskell, Elixir, F#      |

---

## ğŸŸ© ProgramaciÃ³n Orientada a Objetos (POO) - Profundizando

> POO es un paradigma basado en el uso de "objetos" que encapsulan datos y comportamiento.

- Se inspira en el mundo real: entidades que tienen **estado** (atributos) y **comportamiento** (mÃ©todos).
- Facilita el modelado, la reutilizaciÃ³n y el mantenimiento del software.

---

## ğŸ”§ Principios Fundamentales de la POO

| Principio      | DescripciÃ³n |
|----------------|-------------|
| **Herencia**       | Una clase puede heredar atributos y mÃ©todos de otra. |
| **Polimorfismo**   | Un mismo mÃ©todo puede comportarse diferente segÃºn el tipo de objeto. |
| **AbstracciÃ³n**    | Se modela solo lo relevante, ocultando detalles innecesarios. |
| **Encapsulamiento** | Se restringe el acceso directo al estado del objeto, usando propiedades o mÃ©todos. |

---

## ğŸ§¬ Herencia â€“ Ejemplo en C\#

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class Animal
{
    public void Eat() => Console.WriteLine("Eating...");
}

public class Dog : Animal
{
    public void Bark() => Console.WriteLine("Woof!");
}
```

`Dog` hereda el mÃ©todo `Eat()` de `Animal`.

---

## ğŸ­ Polimorfismo â€“ Ejemplo

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class Animal
{
    public virtual void Speak() => Console.WriteLine("Some sound");
}

public class Cat : Animal
{
    public override void Speak() => Console.WriteLine("Meow");
}

public class Dog : Animal
{
    public override void Speak() => Console.WriteLine("Woof");
}
```

Un mismo mÃ©todo (`Speak`) tiene diferentes implementaciones.

---

## ğŸ¨ AbstracciÃ³n â€“ Ejemplo

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public abstract class PaymentMethod
{
    public abstract void Pay(decimal amount);
}
```

Solo se define lo necesario para el diseÃ±o. Cada subclase implementa `Pay` como corresponda.

---

## ğŸ”’ Encapsulamiento â€“ Ejemplo

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class Account
{
    private decimal balance;

    public void Deposit(decimal amount)
    {
        if (amount > 0)
            balance += amount;
    }

    public decimal GetBalance() => balance;
}
```

El acceso al atributo `balance` estÃ¡ protegido.

---

## ğŸ—ï¸ CaracterÃ­sticas del paradigma orientado a objetos

- **Clases abstractas:** permiten definir comportamiento base con mÃ©todos abstractos.
- **Clases concretas:** contienen la lÃ³gica especÃ­fica y pueden ser instanciadas.
- **Interfaces:** definen contratos que deben cumplirse sin especificar implementaciÃ³n.
- **Visibilidad:** (`public`, `private`, `protected`, `internal`) controla el acceso entre objetos.

---

## ğŸ”— Â¿CÃ³mo se relaciona esto con SOLID?

- **SOLID** se apoya completamente en los principios de la POO.
- Mejora cÃ³mo usamos **herencia, interfaces y abstracciÃ³n** para mantener bajo acoplamiento.
- Ayuda a diseÃ±ar sistemas mÃ¡s **seguros, sostenibles y mantenibles**.

---

## ğŸ”¥ Â¿QuÃ© es SOLID?

> Un conjunto de principios que buscan mejorar la mantenibilidad, extensibilidad y calidad del software.

- Introducido por Robert C. Martin (Uncle Bob).
- Aplica principalmente a diseÃ±o orientado a objetos.
- Ayuda a reducir "code smells" y errores de arquitectura.

---

## ğŸ¦¨ Code Smells comunes

- Rigidez: difÃ­cil de cambiar.
- Fragilidad: cambios rompen muchas partes.
- Inmovilidad: difÃ­cil de reutilizar.
- Viscosidad: es mÃ¡s fÃ¡cil hacer "hacks" que hacerlo bien.
- RepeticiÃ³n innecesaria.
- Complejidad innecesaria.
- Opacidad: difÃ­cil de entender.

---

## ğŸ¦¨ Code Smells en el diseÃ±o de software

> Un *code smell* es una seÃ±al de que algo podrÃ­a estar mal con el diseÃ±o o implementaciÃ³n de un sistema.

No necesariamente son bugs, pero **aumentan el riesgo de errores y dificultan el mantenimiento**.

---

## ğŸ§± 1. Rigidez

> â€œEs difÃ­cil cambiar algo sin afectar muchas otras partes.â€

### Ejemplo:

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class InvoiceProcessor
{
    public void ProcessInvoice()
    {
        // lÃ³gica de procesamiento
        GeneratePDF(); // muy acoplado
    }

    private void GeneratePDF()
    {
        // lÃ³gica especÃ­fica para PDF
    }
}
```

Cambiar la forma de exportar implicarÃ­a cambiar esta clase.

---

## ğŸ’¥ 2. Fragilidad

> â€œCambios pequeÃ±os rompen otras partes del sistema inesperadamente.â€

### Ejemplo:

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class UIController
{
    public void ChangeTheme()
    {
        // Cambia colores... pero afecta impresiÃ³n sin saberlo
        ReportTable.Style = "dark";
    }
}
```

Cambiar un color rompe otras partes que reutilizan la misma tabla.

---

## âš“ 3. Inmovilidad

> â€œEl cÃ³digo Ãºtil no se puede reutilizar fÃ¡cilmente.â€

### Ejemplo:

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class DataExporter
{
    public void ExportToCSV(List<User> users, string path)
    {
        // Contiene lÃ³gica para leer archivo de configuraciÃ³n, logs, etc.
    }
}
```

No se puede usar fÃ¡cilmente en otro proyecto sin llevar dependencias innecesarias.

---

## ğŸ©¹ 4. Viscosidad

> â€œEs mÃ¡s fÃ¡cil hacer un *hack* que seguir el diseÃ±o correcto.â€

### Ejemplo:

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class OrderService
{
    public void CancelOrder(int id)
    {
        // Esto estÃ¡ bien...
    }

    public void EmergencyCancel(int id)
    {
        // Copia y pega todo el cÃ³digo anterior con ligeros cambios
    }
}
```

Un cambio urgente se hace mal, por presiÃ³n o falta de claridad.

---

## ğŸ“‹ 5. RepeticiÃ³n innecesaria

> â€œCopy-paste en vez de abstraer o reutilizar.â€

### Ejemplo:

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class MathUtils
{
    public double CalcAreaCircle(double r) => Math.PI * r * r;
    public double CalcAreaAnotherCircle(double r) => 3.1416 * r * r;
}
```

Mismo cÃ¡lculo, duplicado con diferencias innecesarias.

---

## ğŸŒ«ï¸ 6. Opacidad

> â€œEl cÃ³digo es difÃ­cil de leer o entender.â€

### Ejemplo:

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public void Z()
{
    var x = 42;
    var y = x * 2;
    var z = y - 1;
    Console.WriteLine(z);
}
```

Sin nombres significativos, no se sabe quÃ© hace el mÃ©todo.

---

## ğŸ•¸ï¸ 7. Complejidad innecesaria

> â€œDiseÃ±o demasiado abstracto para un problema simple.â€

### Ejemplo:

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public abstract class AbstractDataLoader<T>
{
    public abstract void Load(T data);
}

public class CustomerDataLoader : AbstractDataLoader<Customer>
{
    public override void Load(Customer data)
    {
        Console.WriteLine("Loading customer...");
    }
}
```

Esto podrÃ­a haber sido un simple mÃ©todo `Load(Customer)`. Demasiada abstracciÃ³n para un caso trivial.

---

# ğŸ—ï¸ SOLID

---

## ğŸ¯ S â€“ Single Responsibility Principle (SRP)

> Una clase debe tener **una Ãºnica razÃ³n para cambiar**.

- Cada clase deberÃ­a hacer **una sola cosa**.
- Mejora la cohesiÃ³n y facilita el mantenimiento.

---

### Ejemplo SRP â€“ Incorrecto

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class ReportGenerator
{
    public void GenerateReport() { /* lÃ³gica */ }

    public void ExportToPDF() { /* lÃ³gica de exportaciÃ³n */ }
}
```

AquÃ­ `ReportGenerator` tiene dos responsabilidades: generar datos y exportar.

---

### Ejemplo SRP â€“ Correcto

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class ReportGenerator
{
    public string GenerateReport() => "Reporte generado";
}

public class PDFExporter
{
    public void Export(string content) { /* exportar a PDF */ }
}
```

Ahora cada clase tiene una sola responsabilidad.

---

## ğŸ”“ O â€“ Open/Closed Principle (OCP)

> **Abierto para extensiÃ³n, cerrado para modificaciÃ³n.**

- PodÃ©s extender una clase sin modificar su cÃ³digo original.
- ComÃºnmente aplicado con interfaces y herencia.

---

### Ejemplo OCP â€“ ViolaciÃ³n

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class AreaCalculator
{
    public double CalculateArea(object shape)
    {
        if (shape is Circle c) return Math.PI * c.Radius * c.Radius;
        if (shape is Square s) return s.Side * s.Side;
        return 0;
    }
}
```

Agregar nuevas formas rompe el cÃ³digo existente.

---

### Ejemplo OCP â€“ Aplicado

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public interface IShape
{
    double Area();
}

public class Circle : IShape
{
    public double Radius { get; set; }
    public double Area() => Math.PI * Radius * Radius;
}

public class Square : IShape
{
    public double Side { get; set; }
    public double Area() => Side * Side;
}

public class AreaCalculator
{
    public double TotalArea(IShape[] shapes) =>
        shapes.Sum(s => s.Area());
}
```

Se pueden agregar nuevas formas sin tocar `AreaCalculator`.

---

## ğŸ”„ L â€“ Liskov Substitution Principle (LSP)

> Una subclase debe poder sustituir a su clase base sin alterar el comportamiento.

- No romper expectativas de quien usa la clase base.
- Subtipos deben comportarse como sus padres.

---

### Ejemplo LSP â€“ ViolaciÃ³n

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class Bird
{
    public virtual void Fly() => Console.WriteLine("Flying...");
}

public class Ostrich : Bird
{
    public override void Fly() =>
        throw new NotImplementedException("I can't fly!");
}
```

`Ostrich` hereda de `Bird`, pero rompe la expectativa de que puede volar.

---

### Ejemplo LSP â€“ Correcto

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public abstract class Bird { }

public interface IFlyingBird
{
    void Fly();
}

public class Sparrow : Bird, IFlyingBird
{
    public void Fly() => Console.WriteLine("Flying...");
}

public class Ostrich : Bird
{
    // No implementa IFlyingBird
}
```

Solo los pÃ¡jaros voladores implementan `IFlyingBird`.

---

## ğŸ§© I â€“ Interface Segregation Principle (ISP)

> Los clientes no deben depender de interfaces que no usan.

- Mejor tener muchas interfaces pequeÃ±as y especÃ­ficas.
- Reduce el acoplamiento innecesario.

---

### Ejemplo ISP â€“ ViolaciÃ³n

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public interface IWorker
{
    void Work();
    void Eat();
}

public class Robot : IWorker
{
    public void Work() => Console.WriteLine("Working...");
    public void Eat() => throw new NotImplementedException();
}
```

`Robot` no deberÃ­a implementar `Eat()`.

---

### Ejemplo ISP â€“ Correcto

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public interface IWorkable
{
    void Work();
}

public interface IFeedable
{
    void Eat();
}

public class Human : IWorkable, IFeedable
{
    public void Work() => Console.WriteLine("Working...");
    public void Eat() => Console.WriteLine("Eating...");
}

public class Robot : IWorkable
{
    public void Work() => Console.WriteLine("Working...");
}
```

---

## â¬†ï¸ D â€“ Dependency Inversion Principle (DIP)

> Depender de **abstracciones**, no de implementaciones concretas.

- Las clases de alto nivel no deben depender de clases de bajo nivel.
- Usar inyecciÃ³n de dependencias.

---

### Ejemplo DIP â€“ ViolaciÃ³n

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public class EmailService
{
    public void Send(string message) => Console.WriteLine($"Email: {message}");
}

public class Notifier
{
    private EmailService _email = new EmailService();
    public void Notify(string message) => _email.Send(message);
}
```

---

### Ejemplo DIP â€“ Aplicado

<!-- language: csharp -->
``` {.csharp .code-line-numbers}
public interface IMessageService
{
    void Send(string message);
}

public class EmailService : IMessageService
{
    public void Send(string message) => Console.WriteLine($"Email: {message}");
}

public class Notifier
{
    private IMessageService _service;

    public Notifier(IMessageService service)
    {
        _service = service;
    }

    public void Notify(string message) => _service.Send(message);
}
```

---

## ğŸ‰ Conclusiones

- SOLID es una guÃ­a prÃ¡ctica para diseÃ±ar sistemas **flexibles y mantenibles**.
- Cada principio ataca uno o mÃ¡s "code smells".
- Aplicar SOLID mejora la arquitectura, incluso en proyectos pequeÃ±os.
- Â¡RecordÃ¡: un buen diseÃ±o **huele bien**!

---

## ğŸ“ Actividad

- Revisar el cÃ³digo de su proyecto.
- Identificar una clase que viole uno de los principios SOLID.
- Refactorizar y explicar quÃ© principio aplicaste y por quÃ©.

---

## ğŸš€ PrÃ³xima clase
- Vamos a ver estilos arquitectÃ³nicos y vamos a necesitar docker para simular cada estilo. Por favor, instalar docker para la prÃ³xima clase.
